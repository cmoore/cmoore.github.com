---
layout: post
title: The great communicator
---

h1. {{ page.title }}

p(meta). I used to dream of language interoperability like this

h1. I will edit this page again later today (2/2/11) with cleaner working code.  Though, I don't know what I'm worried about - I'm pretty sure I'm the only one that reads this.

In case you haven't heard, 0MQ is what we would end up with if we had to design the socket interface today.  Well, at least I think that.  Here's an example of why.

First, I'll define a very simple message format.

{% highlight javascript %}

{ op: "parse_urls",
  data: "This might be a tweet. http://www.slashdot.org or something." }

{% endhighlight %}

Where 'op' is the operation to perform, and data is the data to do it on.

Then the response would look something like this.

{% highlight javascript %}

{ result: "This might be a tweet. <a href=\"http://www.slashdot.org/\">http://www.slashdot.org/</a>" }

{% endhighlight %}


Now, let's say you really like Parsec and Haskell's speed at which it can parse text with it.  Let's further assume that you had written something like this:

{% highlight haskell %}

module Main where

import Text.ParserCombinators.Parsec
import Text.Groom
import Data.List (intersperse)

main :: IO ()
main = do
  putStrLn $ groom $ concat $ intersperse " " $ map mkp $
    words "This is a tweet that might http://www.honk.com/ have a link inside."
 where
   mkp :: String -> String
   mkp wrd =
     case parse url "" wrd of
       Right b -> b
       Left _ -> wrd

url :: Parser String
url = do
  uri <- string "http:" <|> string "https:"
  _ <- string "//"
  rest <- many $ noneOf " "
  return $ urlify $ uri ++ "//" ++ rest
 where
   urlify :: String -> String
   urlify b = "<a href=\"" ++ b ++ "\">" ++ b ++ "</a>"

{% endhighlight %}

Granted, this isn't the prettiest code in the world, but it's simple and it does work for at least most links.  Ok, well, a lot of links.

How can I use this in Lua, Ada, Basic, C, C++, C#, Chicken Scheme, D, Erlang, Go, Haskell (lawl), Java, node.js, Obj-C, ooc, Perl, Python, Racket, Ruby, or Tcl, as well as have it accessable and fast enough that it makes sense not to rewrite it for every language?  Well, I'll show you one way.


{% highlight ruby %}
context = ZMQ::Context.new(1)
trap "INT", proc {
  context.terminate()
  exit
}

sock = context.socket( ZMQ::REQ )
sock.connect( "tcp://127.0.0.1:6767" )
sock.send_string(
  [ :op => "parse_urls",
    :data => "This might be a tweet http://slashdot.org with a url inside." ] )
parsed = sock.recv_string()
{% endhighlight %}


While this may be fun to play with, it's obviously not practical to have to make sure that there is another program available to provide url parsing.

What we really need is Erlang-style message passing.  Hrm...